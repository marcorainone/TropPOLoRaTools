#!/usr/bin/env python3
# ===================================================================================
# Project:    TropPo 
#             v. 1.0 2020-03-01, ICTP Wireless Lab
# Programmer: Marco Rainone - ICTP Wireless Lab
# Specifications, revisions and verifications:   
#             Marco Zennaro, Ermanno Pietrosemoli, Marco Rainone - ICTP Wireless Lab
# ===================================================================================
#
# The project is released with Mit License
# https://opensource.org/licenses/MIT
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ===================================================================================
#
# Info
# ----------------------------------------------------------------
# receives a csv file generated by inpnear.py or rsigra-near.py. 
# Generates an html graphic map with the location of the device, gateway and igra radiosonde.

import os
import os.path
import getopt, sys
import datetime

import numpy as np
import pandas as pd
from collections import namedtuple
import matplotlib.pyplot as plt
from staticmap import StaticMap, CircleMarker
import csv, json, sys
import geopy.distance
from array import *

import folium

# ---------------------------------------------------------------
# config
#
PathBaseDir = os.getcwd()               # current working directory of the process
access_rights = 0o777                   # define the access rights file/folder
csv_sep = ';'                           # char separator for csv

# -------------------------------------------------------------------------
#
# get full path file or directory
def get_full_path(file_folder_name):
    return (os.path.abspath(file_folder_name))

# check if the full path is file
def is_directory(full_path):
    # os.path.exists checks whether a file or directory exists:
    ris = os.path.exists(full_path)
    if ris:
        # os.path.isdir checks whether it's a directory
        return (os.path.isdir(full_path))
    return False            # the path is not directory

# check if the full path is file
def is_file_name(full_path):
    # os.path.exists checks whether a file or directory exists:
    ris = os.path.exists(full_path)
    if ris:
        # os.path.isdir checks whether it's a directory
        return (not os.path.isdir(full_path))
    return False            # the path is not filename

def get_dir_name(full_path):
    dirname = os.path.dirname(full_path)    # os independent
    return dirname

# return the file name without path
def get_file_name(full_path):
    basename = os.path.basename(full_path)  # os independent
    base = basename.split('.')[0]
    return base

# return the extension of file
def get_file_ext(full_path):
    basename = os.path.basename(full_path)  # os independent
    ext = '.'.join(basename.split('.')[1:])
    if ext == '.':
        return ""
    return ext

def str2bool(v):
    return v.lower() in ("yes", "true", "t", "1")

def printHlpOptions():
    print('{} -i <log TTN events> -o <out dir>'.format(sys.argv[0]))

def printHlpFull():
    print('{} -i <log TTN events> -o <out dir>'.format(sys.argv[0]))
    print('Example:')
    print('{} -i budnag-20190828.csv -o outdir'.format(sys.argv[0]))
    print('Read budnag-20190828.csv.'.format(sys.argv[0]))
    print('Store html map in ./output directory')

# -------------------------------------------------------------------------
def get_bearing(p1, p2):
    
    '''
    Returns compass bearing from p1 to p2
    
    Parameters
    p1 : namedtuple with lat lon
    p2 : namedtuple with lat lon
    
    Return
    compass bearing of type float
    
    Notes
    Based on https://gist.github.com/jeromer/2005586
    '''
    
    long_diff = np.radians(p2.lon - p1.lon)
    
    lat1 = np.radians(p1.lat)
    lat2 = np.radians(p2.lat)
    
    x = np.sin(long_diff) * np.cos(lat2)
    y = (np.cos(lat1) * np.sin(lat2) 
        - (np.sin(lat1) * np.cos(lat2) 
        * np.cos(long_diff)))
    bearing = np.degrees(np.arctan2(x, y))
    
    # adjusting for compass bearing
    if bearing < 0:
        return bearing + 360
    return bearing
    
def get_arrows(locations, color='black', size=6, n_arrows=3):
    
    '''
    Get a list of correctly placed and rotated 
    arrows/markers to be plotted
    
    Parameters
    locations : list of lists of lat lons that represent the 
                start and end of the line. 
                eg [[41.1132, -96.1993],[41.3810, -95.8021]]
    arrow_color : default is 'blue'
    size : default is 6
    n_arrows : number of arrows to create.  default is 3
    Return
    list of arrows/markers
    '''
    
    Point = namedtuple('Point', field_names=['lat', 'lon'])
    
    # creating point from our Point named tuple
    p1 = Point(locations[0][0], locations[0][1])
    p2 = Point(locations[1][0], locations[1][1])
    
    # getting the rotation needed for our marker.  
    # Subtracting 90 to account for the marker's orientation
    # of due East(get_bearing returns North)
    rotation = get_bearing(p1, p2) - 90
    
    # get an evenly space list of lats and lons for our arrows
    # note that I'm discarding the first and last for aesthetics
    # as I'm using markers to denote the start and end
    arrow_lats = np.linspace(p1.lat, p2.lat, n_arrows + 2)[1:n_arrows+1]
    arrow_lons = np.linspace(p1.lon, p2.lon, n_arrows + 2)[1:n_arrows+1]
    
    arrows = []
    
    #creating each "arrow" and appending them to our arrows list
    for points in zip(arrow_lats, arrow_lons):
        arrows.append(folium.RegularPolygonMarker(location=points, 
                      fill_color=color, number_of_sides=3, 
                      radius=size, rotation=rotation))
    return arrows
    
# -------------------------------------------------------------------------
# Get command-line arguments

# initialize variables
inpTTNEventsLog = ''
OutDirMap = ''
minDist = 20
flCaseGtwId = True

try:
    opts, args = getopt.getopt(
            sys.argv[1:],
            'i:o:',
            ["inp=","out="])
except getopt.GetoptError:
    printHlpFull()              # print full help
    sys.exit(2)

nArg = 0
# print(opts)
# print(args)
for opt, arg in opts:
    if opt == '-h':
        printHlpFull()              # print full help
        sys.exit()
    elif opt in ("-i", "--inp"):
        inpTTNEventsLog = arg
        # print('TTN Mapper Log file: {}'.format(inpTTNEventsLog))
        nArg = nArg + 1
    elif opt in ("-o", "--out"):
        OutDirMap = arg
        # print('Output directory map result: {}'.format(OutDirMap))
        nArg = nArg + 1

# print(nArg)
        
if nArg < 2:
    printHlpFull()              # print full help
    sys.exit()

# ---------------------------------------------------------------
# in base of inpTTNMapperLog, get file name and extension
# full path inpTTNMapperLog
fpTTNEventsLog = os.path.join(PathBaseDir, inpTTNEventsLog)

# get filename of output map file
OutMapFile = 'map-' + get_file_name(inpTTNEventsLog) + '.html'
# full path output dir
if not os.path.exists(OutDirMap):
    os.mkdir(OutDirMap, access_rights)
fpOutDir = get_full_path(OutDirMap)     # full path output dir

outDirRadioSonda = fpOutDir

# full path output file
fpOutMapFile = os.path.join(fpOutDir, OutMapFile)
                                                  
# -------------------------------------------------------------------------
# column_names = ['time','distance','nodeaddr','lat','lon','gwaddr','gtw_lat','gtw_lon']
data = pd.read_csv(fpTTNEventsLog, skipinitialspace = True, sep = csv_sep)
print(data)

data.drop_duplicates(['nodeaddr','gwaddr'], inplace=True)
# reindex
data.reset_index(drop=True, inplace=True)

# values used from csv:
# lat
# lon
# gtw_lat
# gtw_lon
# rs_lat
# rs_lon

max_lat  = data['lat'].max()
max_lat += data['gtw_lat'].max()
max_lat += data['rs_lat'].max()
min_lat  = data['lat'].min()
min_lat += data['gtw_lat'].min()
min_lat += data['rs_lat'].min()

max_lon  = data['lon'].max()
max_lon += data['gtw_lon'].max()
max_lon += data['rs_lon'].max()
min_lon  = data['lon'].min()
min_lon += data['gtw_lon'].min()
min_lon += data['rs_lon'].min()

ave_lat = (max_lat + min_lat) / 6.0
ave_lon = (max_lon + min_lon) / 6.0

this_map = folium.Map(location=[ave_lat, ave_lon], zoom_start=9)

for i1 in data.index:
    print("row index: {}...".format(i1))
    
    # radiosonda
    strPop_radiosonda = "'Radiosonde IGRA:<br>{}<br>({:.4f},{:.4f})".format(
                    data.iloc[i1]['rs_id'],
                    data.iloc[i1]['rs_lat'], data.iloc[i1]['rs_lon']
                    )
    this_map.add_child(
        folium.Marker(location=[data.iloc[i1]['rs_lat'], data.iloc[i1]['rs_lon']], 
                    popup= folium.Popup(strPop_radiosonda, sticky=True, show=True),
                    icon=folium.Icon(icon = 'cloud', color='orange', icon_color='white')
                    )
    )
    # device
    strPop_device = "{}<br>({:.4f},{:.4f})".format(
                    data.iloc[i1]['nodeaddr'],
                    data.iloc[i1]['lat'], data.iloc[i1]['lon']
                    )
    this_map.add_child(
        folium.CircleMarker(location=[data.iloc[i1]['lat'], data.iloc[i1]['lon']],
                    fill='true',
                    radius = 10,
                    popup= folium.Popup(strPop_device, sticky=True, show=True),
                    fill_color='red',
                    color = 'clear',
                    fill_opacity=1
                    )
    )
    # gateway
    strPop_gateway = "{}<br>({:.4f},{:.4f})".format(
                    data.iloc[i1]['gwaddr'],
                    data.iloc[i1]['gtw_lat'], data.iloc[i1]['gtw_lon']
                    )
    this_map.add_child(
        folium.CircleMarker(location=[data.iloc[i1]['gtw_lat'], data.iloc[i1]['gtw_lon']],
                    fill='true',
                    radius = 10,
                    popup= folium.Popup(strPop_gateway, sticky=True, show=True),
                    fill_color='blue',
                    color = 'clear',
                    fill_opacity=1
                    )
    )
    # median point 1
    # calculate median point of coordinates from device to gateway
    mlat = (data['lat'][i1] + data['gtw_lat'][i1]) / 2.0
    mlon = (data['lon'][i1] + data['gtw_lon'][i1]) / 2.0
    strPop_median = "Transmission distance:<br>{}km".format(
                    (int(data.iloc[i1]['distance']))
                    )
    this_map.add_child(
        folium.CircleMarker(location=[mlat, mlon],
                    fill='true',
                    radius = 4,
                    popup= folium.Popup(strPop_median, sticky=True, show=True),
                    fill_color='black',
                    color = 'clear',
                    fill_opacity=1
                    )
    )
    # median point 2
    # calculate median point of coordinates from previous median point to radiosonda
    mlat_radio = (mlat + data['rs_lat'][i1]) / 2.0
    mlon_radio = (mlon + data['rs_lon'][i1]) / 2.0
    strPop_median_radio = " radiosonde dist. to trajectory center:<br>{}km".format(
                    (int(data.iloc[i1]['rs_distance']))
                    )
    this_map.add_child(
        folium.CircleMarker(location=[mlat_radio, mlon_radio],
                    fill='true',
                    radius = 2.5,
                    popup= folium.Popup(strPop_median_radio, sticky=True, show=True),
                    fill_color='black',
                    color = 'clear',
                    fill_opacity=1
                    )
    )
    
    # points of line
    points_txrx = [
        [data.iloc[i1]['lat'], data.iloc[i1]['lon']] ,
        [mlat, mlon],
        [data.iloc[i1]['gtw_lat'], data.iloc[i1]['gtw_lon']]
        ]
    # add line
    this_map.add_child(
        folium.PolyLine(points_txrx,
                    # popup= folium.Popup(str(int(data.iloc[i1]['distance'])) + 'km', sticky=True),
                    color="red", weight=2.5, opacity=1)
    )

    points_event = [
        [data.iloc[i1]['lat'], data.iloc[i1]['lon']] ,
        [data.iloc[i1]['gtw_lat'], data.iloc[i1]['gtw_lon']]
        ]
    arrows = get_arrows(locations=points_event, color='black', n_arrows=3)
    for arrow in arrows:
        arrow.add_to(this_map)

    # points of line
    points_b = [
        [data.iloc[i1]['rs_lat'], data.iloc[i1]['rs_lon']] ,
        [mlat, mlon]
        ]
    # add line
    this_map.add_child(
        folium.PolyLine(points_b,
                    # popup= folium.Popup(str(int(data.iloc[i1]['distance'])) + 'km', sticky=True),
                    color="red",  dash_array='10', weight=1.5, opacity=1)
    )
    
    # this_map.add_child(folium.LatLngPopup())

# Save map
this_map.save(fpOutMapFile)
    
